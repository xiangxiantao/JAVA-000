学习笔记

# 3.JVM类加载器



## 3.1类加载的7个步骤

1. 加载 ：寻找class的过程（文件，网络等等位置）
2. 验证： 验证格式、依赖
3. 准备：静态字段、方法表（类的结构）
4. 解析：符号解析为引用
5. 初始化：构造器、静态变量、静态代码块的初始值
6. 使用
7. 卸载



## 3.2类加载的时机：

1. 虚拟机启动时回加载Main方法所在的类
2. new指令会加载目标类
3. 调用类的静态方法会加载类
4. 访问类的静态属性会加载类
5. 初始化子类时会先初始化父类
6. 调用接口的default方法是会初始化该接口
7. 反射api
8. MethodHandler方法引用所关联的类



## 3.3类不会被初始化的时机

1. 通过子类引用父类的静态字段，只会初始化父类，而不会初始化子类
2. 定义一个对象数组时不会触发类的初始化
3. 调用类中的静态常量池中的常量时不会触发类的初始化

```java
public static final String s = "hello";
```

4. A.class 不会触发类的初始化，只会触发类的加载

5. Class.forName加载指定类时，通过参数initialize指定是否进行初始化，默认会进行初始化
6. 通过classLoader默认的loadClass方法，不会触发初始化，只会加载



## 3.4三类加载器

1. 启动类加载器：BootstrapClassLoader
2. 扩展类加载器：ExtClassLoader
3. 应用类加载器：AppClassLoader



## 3.5类加载器机制的特点

1. 双亲委派
2. 负责依赖
3. 缓存加载

通过类加载器可以实现相同类型的隔离



## 3.6实操：

1.显示当前ClassLoader加载了哪些jar

2.自定义类加载器：加载通过base64编码之后的class文件

​	自定义classLoader，并实现findClass()



## 3.7添加引用类的几种方式

1.直接放到jdk路径下的lib/ext 或者启动参数-Djava.ext.dirs,指定之后，将会由扩展类加载器将其加载

2.启动参数java -cp 或者直接将class文件放到当前路径

3.自定义类加载器用于加载第三方类或jar包

4.拿到当前执行类的ClassLoader，反射调用addUrl方法添加jar或者路径



# 4.JVM内存模型

## 4.1线程独享内存空间：

1. PC计数器
2. 本地方法栈
3. 虚拟机栈



## 4.2线程共享内存空间

​	1.堆内存

​	2.方法区

​	3.运行时常量池

​	4.直接内存



## 4.3常用参数：

-Xmx

-Xms

-Xss: 每个线程的堆栈大小 



当Xmx=4g时，一般实际java进程占用的总内存在5个G以上，通常Xmx的值设置为操作系统总内存的70%



## 4.4CPU内存行为

1. CPU乱序执行
2. colatile关键字
3. 原子性操作
4. 内存屏障 



## 4.5什么是JMM？



# 5.JVM启动参数

## 5.1启动参数设置类型

1. -：标准参数，所有JVM都需要实现，且向后兼容

2. -D:系统属性

3. -X:非标准参数：可以使用java -X命令来查看当前JVM支持哪些-X参数

4. -XX：非稳定参数

   +-Flags形式对bool值进行设置

   key=value



## 5.2启动参数作用类型

1. 系统属性参数
2. 运行模式参数 -Server -Client
3. 堆内存设置参数 -Xmx -Xms -Xss
4. gc设置参数
5. 分析诊断参数
6. JavaAgent参数